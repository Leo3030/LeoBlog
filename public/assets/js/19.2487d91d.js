(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{448:function(t,a,e){"use strict";e.r(a);var v=e(2),_=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"历史背景及特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#历史背景及特性"}},[t._v("#")]),t._v(" 历史背景及特性")]),t._v(" "),a("h3",{attrs:{id:"问题根源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题根源"}},[t._v("#")]),t._v(" 问题根源")]),t._v(" "),a("ul",[a("li",[t._v("传统 UI 操作（DOM API）关注太多细节")]),t._v(" "),a("li",[t._v("应用程序状态分散在各处，难以追踪和维护")])]),t._v(" "),a("h3",{attrs:{id:"react-思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-思想"}},[t._v("#")]),t._v(" React 思想")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("UI 细节：始终整体“刷新”页面，无需关心细节")])]),t._v(" "),a("li",[a("p",[t._v("数据模型：")]),t._v(" "),a("ul",[a("li",[t._v("Flux 架构：单向数据流")]),t._v(" "),a("li",[t._v("实现：\n"),a("ul",[a("li",[t._v("Redux")]),t._v(" "),a("li",[t._v("Mobx")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:"/images/202205171431001.png",alt:"Alt Text"}})])])]),t._v(" "),a("h2",{attrs:{id:"什么是-react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-react"}},[t._v("#")]),t._v(" 什么是 React？")]),t._v(" "),a("ul",[a("li",[t._v("React 是一个 js 的库，一个前端的 ui 框架，通过组件化 UI 来解决图层开发复用的问题，本质是一个组件化的框架")]),t._v(" "),a("li",[t._v("React 的核心设计思路有三点\n"),a("ul",[a("li",[a("strong",[t._v("申明式：")]),t._v(" React 通过申明组件的方式，更好的方便了项目的阅读，比起 JQuery 那种命令式的开发方式，申明式无疑更加的直观和便于组合")]),t._v(" "),a("li",[a("strong",[t._v("组件化：")]),t._v(" React 通过组件化的方式，让视图的拆分和复用，更加的简单高效，做到了高内聚低耦合")]),t._v(" "),a("li",[a("strong",[t._v("通用性：")]),t._v(" React 基于虚拟 Dom 来进行操作 UI，所以可以在各种平台运行，比如说 ios/android，小程序等等")])])]),t._v(" "),a("li",[t._v("React 的缺点：\n"),a("ul",[a("li",[t._v("作为一个视图层的框架，React 并没有提供一套完整的大型应用的解决方案。比如说页面的 router，server 等，需要依赖别的解决方案，比如说 express..js 或者 next.js 等等")])])])]),t._v(" "),a("h2",{attrs:{id:"react-为什么要用-jsx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-为什么要用-jsx"}},[t._v("#")]),t._v(" React 为什么要用 JSX")]),t._v(" "),a("h3",{attrs:{id:"官方定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#官方定义"}},[t._v("#")]),t._v(" 官方定义")]),t._v(" "),a("p",[t._v("JSX 是 JS 的语法拓展，或者是一个类似于 XML 的 es 语法拓展")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("React 官方并不强制使用 JSX，也可以使用 React.createElement 来实现同样的功能，但是使用 JSX 的写法会比直接使用 createElement 更加简单，易读，JSX 最后会通过 babel 转换成 createElement，所以 JSX 更像是 createElement 的语法糖")])]),a("h3",{attrs:{id:"其他方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他方案"}},[t._v("#")]),t._v(" 其他方案")]),t._v(" "),a("ul",[a("li",[t._v("模版")]),t._v(" "),a("li",[t._v("模版字符串")])]),t._v(" "),a("h3",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),a("ul",[a("li",[t._v("挂载\n"),a("ul",[a("li",[t._v("constructor （严格来说这个不算 React 的生命周期，这个是类的构造函数）")]),t._v(" "),a("li",[t._v("UNSAFE_componentWillMount (弃用)")]),t._v(" "),a("li",[t._v("componentDidMount (组件完成挂载是触发，适合写一些初始化异步调用后台数据的逻辑)")])])]),t._v(" "),a("li",[t._v("更新\n"),a("ul",[a("li",[t._v("componentWillReceiveProps （弃用）")]),t._v(" "),a("li",[t._v("componentWShouldUpdate （更新前出发，能够阻止更新，节省不必要额资源，是优化的方向之一）")])])]),t._v(" "),a("li",[t._v("卸载\n"),a("ul",[a("li",[t._v("componentWillMount （在组件卸载的时候触发，可以用于删除事件等操作）")])])]),t._v(" "),a("li",[t._v("异常\n"),a("ul",[a("li",[t._v("componentCatchError（用于处理因为 js 出错而导致的白屏问题）")])])])]),t._v(" "),a("h3",{attrs:{id:"如何避免生命周期中的坑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何避免生命周期中的坑"}},[t._v("#")]),t._v(" 如何避免生命周期中的坑")]),t._v(" "),a("ul",[a("li",[t._v("已经移除的生命周期状态需要做逻辑的")])]),t._v(" "),a("p",[t._v("TODO：")])])}),[],!1,null,null,null);a.default=_.exports}}]);